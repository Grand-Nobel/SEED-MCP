# supabase.py\nfrom fastapi import APIRouter, HTTPException, Request, Query\nfrom supabase import create_client, Client\nimport os\nfrom pydantic import BaseModel\nfrom typing import Dict, Any, Optional, List, Union # Added Union\nimport json # For parsing filters_json in get_table_data_endpoint\n\n# Import the custom Supabase tools\nfrom tools.supabase import supabase_tools\n\nrouter = APIRouter()\n\nSUPABASE_URL = os.getenv("access token")\nSUPABASE_API_KEY = os.getenv("anon_key")\n\nif not SUPABASE_URL or not SUPABASE_API_KEY:\n    raise EnvironmentError("Missing Supabase credentials")\n\nsupabase: Client = create_client(SUPABASE_URL, SUPABASE_API_KEY)\n\n@router.post("/functions/v1/ask-mcp")\nasync def ask_mcp(request: Request):\n    data = await request.json()\n    try:\n        # Example query: insert into 'logs' table\n        result = supabase.table("logs").insert({"payload": data}).execute()\n        return {"status": "success", "data": result.data}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n# Pydantic Models for Tenant Theme\nclass ThemeTypography(BaseModel):\n    font_family_base: Optional[str] = None\n    font_size_base: Optional[str] = None\n\nclass TenantThemeResponse(BaseModel):\n    tenant_id: str\n    primary_color: Optional[str] = None\n    secondary_color: Optional[str] = None\n    font_family: Optional[str] = None\n    typography_config: Optional[ThemeTypography] = None\n\nclass GetTenantThemeResponse(BaseModel):\n    status: str\n    data: Optional[TenantThemeResponse] = None\n    message: Optional[str] = None\n\n@router.get("/themes/{tenant_id}", response_model=GetTenantThemeResponse)\nasync def get_theme_by_tenant_id(tenant_id: str):\n    try:\n        theme_data = supabase_tools.get_tenant_theme(db_client=supabase, tenant_id=tenant_id)\n        if theme_data:\n            return {"status": "success", "data": theme_data}\n        else:\n            raise HTTPException(status_code=404, detail=f"Theme not found for tenant {tenant_id}")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_theme_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching theme for tenant {tenant_id}.")\n\n\n# Pydantic Models for Log UI Event\nclass LogUiEventRequest(BaseModel):\n    tenant_id: str\n    event_type: str\n    payload: Dict[str, Any]\n\nclass LogUiEventResponse(BaseModel):\n    status: str\n    event_id: Optional[str] = None\n    message: Optional[str] = None\n\n@router.post("/events/ui", response_model=LogUiEventResponse)\nasync def log_ui_event_endpoint(request: LogUiEventRequest):\n    try:\n        event_id = supabase_tools.log_ui_event(\n            db_client=supabase,\n            tenant_id=request.tenant_id,\n            event_type=request.event_type,\n            payload=request.payload\n        )\n        if event_id:\n            return {"status": "success", "event_id": event_id}\n        else:\n            raise HTTPException(status_code=500, detail="Failed to log UI event due to an internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in log_ui_event_endpoint: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected error occurred while logging the UI event.")\n\n\n# Pydantic Models for Tenant Validation Rules\nclass TenantValidationRules(BaseModel):\n    rules: Dict[str, Any]\n\nclass GetTenantValidationRulesResponse(BaseModel):\n    status: str\n    data: Optional[TenantValidationRules] = None\n    message: Optional[str] = None\n\n@router.get("/validation-rules/{tenant_id}", response_model=GetTenantValidationRulesResponse)\nasync def get_validation_rules_by_tenant_id(tenant_id: str):\n    try:\n        rules_data = supabase_tools.get_tenant_validation_rules(db_client=supabase, tenant_id=tenant_id)\n        if rules_data is not None:\n            return {"status": "success", "data": {"rules": rules_data}}\n        else:\n            raise HTTPException(status_code=404, detail=f"Validation rules not found for tenant {tenant_id} or an error occurred.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_validation_rules_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching validation rules for tenant {tenant_id}.")\n\n\n# Pydantic Models for Tenant Table Configuration\nclass GetTenantTableConfigResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n\n@router.get("/table-configurations/{tenant_id}", response_model=GetTenantTableConfigResponse)\nasync def get_table_config_by_tenant_id(tenant_id: str):\n    try:\n        table_configs = supabase_tools.get_tenant_table_config(db_client=supabase, tenant_id=tenant_id)\n        if table_configs is not None:\n            return {"status": "success", "data": table_configs}\n        else:\n            raise HTTPException(status_code=404, detail=f"Table configurations not found for tenant {tenant_id} or an error occurred.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_table_config_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching table configurations for tenant {tenant_id}.")\n\n\n# Pydantic Models for Tenant Accessibility Configuration\nclass GetTenantAccessibilityConfigResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n\n@router.get("/accessibility-configurations/{tenant_id}", response_model=GetTenantAccessibilityConfigResponse)\nasync def get_accessibility_config_by_tenant_id(tenant_id: str):\n    try:\n        accessibility_configs = supabase_tools.get_tenant_accessibility_config(db_client=supabase, tenant_id=tenant_id)\n        if accessibility_configs is not None:\n            return {"status": "success", "data": accessibility_configs}\n        else:\n            raise HTTPException(status_code=404, detail=f"Accessibility configurations not found for tenant {tenant_id} or an error occurred.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_accessibility_config_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching accessibility configurations for tenant {tenant_id}.")\n
# Pydantic Models for Tenant Icon Set Configuration\nclass GetTenantIconSetConfigResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None \n    message: Optional[str] = None\n\n@router.get("/icon-set-configurations/{tenant_id}", response_model=GetTenantIconSetConfigResponse)\nasync def get_icon_set_config_by_tenant_id(tenant_id: str):\n    try:\n        icon_set_configs = supabase_tools.get_tenant_icon_set_config(db_client=supabase, tenant_id=tenant_id)\n        if icon_set_configs is not None:\n            return {"status": "success", "data": icon_set_configs}\n        else:\n            raise HTTPException(status_code=404, detail=f"Icon set configurations not found for tenant {tenant_id} or an error occurred.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_icon_set_config_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching icon set configurations for tenant {tenant_id}.")\n
# Pydantic Models for Tenant Grid Configuration\nclass GetTenantGridConfigResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n\n@router.get("/grid-configurations/{tenant_id}", response_model=GetTenantGridConfigResponse)\nasync def get_grid_config_by_tenant_id(tenant_id: str):\n    try:\n        grid_configs = supabase_tools.get_tenant_grid_config(db_client=supabase, tenant_id=tenant_id)\n        if grid_configs is not None:\n            return {"status": "success", "data": grid_configs}\n        else:\n            raise HTTPException(status_code=404, detail=f"Grid configurations not found for tenant {tenant_id} or an error occurred.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_grid_config_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching grid configurations for tenant {tenant_id}.")\n\n\n# Pydantic Models for Log System Event\nclass LogSystemEventRequest(BaseModel):\n    tenant_id: Optional[str] = None\n    event_type: str\n    payload: Dict[str, Any]\n\nclass LogSystemEventResponse(BaseModel):\n    status: str\n    event_id: Optional[str] = None\n    message: Optional[str] = None\n\n@router.post("/events/system", response_model=LogSystemEventResponse)\nasync def log_system_event_endpoint(request: LogSystemEventRequest):\n    try:\n        event_id = supabase_tools.log_system_event(\n            db_client=supabase,\n            tenant_id=request.tenant_id,\n            event_type=request.event_type,\n            payload=request.payload\n        )\n        if event_id:\n            return {"status": "success", "event_id": event_id}\n        else:\n            raise HTTPException(status_code=500, detail="Failed to log system event due to an internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in log_system_event_endpoint: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected error occurred while logging the system event.")\n\n\n# Pydantic Models for Log System Metric\nclass LogSystemMetricRequest(BaseModel):\n    tenant_id: Optional[str] = None\n    metric_name: str\n    value_payload: Dict[str, Any]\n\nclass LogSystemMetricResponse(BaseModel):\n    status: str\n    metric_id: Optional[str] = None\n    message: Optional[str] = None\n\n@router.post("/metrics/system", response_model=LogSystemMetricResponse)\nasync def log_system_metric_endpoint(request: LogSystemMetricRequest):\n    try:\n        metric_id = supabase_tools.log_system_metric(\n            db_client=supabase,\n            tenant_id=request.tenant_id,\n            metric_name=request.metric_name,\n            value_payload=request.value_payload\n        )\n        if metric_id:\n            return {"status": "success", "metric_id": metric_id}\n        else:\n            raise HTTPException(status_code=500, detail="Failed to log system metric due to an internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in log_system_metric_endpoint: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected error occurred while logging the system metric.")\n\n\n# Pydantic Models for Tenant Service Configuration\nclass GetTenantServiceConfigResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n\n@router.get("/service-configurations/{tenant_id}", response_model=GetTenantServiceConfigResponse)\nasync def get_service_config_by_tenant_id(tenant_id: str):\n    try:\n        service_configs = supabase_tools.get_tenant_service_config(db_client=supabase, tenant_id=tenant_id)\n        if service_configs is not None:\n            return {"status": "success", "data": service_configs}\n        else:\n            raise HTTPException(status_code=404, detail=f"Service configurations not found for tenant {tenant_id} or an error occurred.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_service_config_by_tenant_id endpoint for tenant {tenant_id}: {e}")\n        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while fetching service configurations for tenant {tenant_id}.")\n\n\n# Pydantic Models for Manage Supabase User\nclass UserDetails(BaseModel):\n    auth_id: Optional[str] = None\n    email: Optional[str] = None\n    full_name: Optional[str] = None\n    role: Optional[str] = None\n    tenant_id: Optional[str] = None\n\nclass ManageSupabaseUserRequest(BaseModel):\n    action: str\n    user_details: UserDetails\n\nclass ManageSupabaseUserResponse(BaseModel):\n    status: str\n    data: Optional[Dict[str, Any]] = None\n    message: Optional[str] = None\n\n@router.post("/users/manage", response_model=ManageSupabaseUserResponse)\nasync def manage_user_endpoint(request: ManageSupabaseUserRequest):\n    try:\n        user_details_dict = request.user_details.model_dump(exclude_none=True)\n        result_data = supabase_tools.manage_supabase_user(\n            db_client=supabase,\n            action=request.action,\n            user_details=user_details_dict\n        )\n        if result_data and "error" not in result_data:\n            return {"status": "success", "data": result_data}\n        elif result_data and "error" in result_data:\n            error_detail = result_data.get("error", "Failed to manage user profile due to an internal error.")\n            status_code = 400 if "required" in error_detail or "no_update_data" in error_detail or "unknown_action" in error_detail else 500\n            if request.action == "get_profile_by_auth_id" and result_data.get("error") and "not found" in result_data.get("error").lower(): # Approximation\n                 status_code = 404\n            raise HTTPException(status_code=status_code, detail=error_detail)\n        elif request.action == "get_profile_by_auth_id" and result_data is None:\n             raise HTTPException(status_code=404, detail=f"User profile not found for auth_id: {request.user_details.auth_id}")\n        else:\n            raise HTTPException(status_code=500, detail="Failed to manage user profile due to an unexpected internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in manage_user_endpoint: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected error occurred while managing the user profile.")\n\n\n# Pydantic Models for Get File Storage URL\nclass GetFileStorageUrlRequest(BaseModel):\n    action: str\n    bucket_name: str\n    file_path: str\n    expires_in: int = 3600\n    content_type: Optional[str] = None\n\nclass FileStorageUrlData(BaseModel):\n    signed_url: Optional[str] = None\n    method: Optional[str] = None\n    path: Optional[str] = None\n    error: Optional[str] = None\n\nclass GetFileStorageUrlResponse(BaseModel):\n    status: str\n    data: Optional[FileStorageUrlData] = None\n    message: Optional[str] = None\n\n@router.post("/storage/url", response_model=GetFileStorageUrlResponse)\nasync def get_storage_url_endpoint(request: GetFileStorageUrlRequest):\n    try:\n        url_data = supabase_tools.get_file_storage_url(\n            db_client=supabase,\n            action=request.action,\n            bucket_name=request.bucket_name,\n            file_path=request.file_path,\n            expires_in=request.expires_in,\n            content_type=request.content_type\n        )\n        if url_data and not url_data.get("error"):\n            return {"status": "success", "data": url_data}\n        elif url_data and url_data.get("error"):\n            error_message = url_data.get("error")\n            status_code = 400 if "Unknown action" in error_message or "not supported" in error_message else 500\n            raise HTTPException(status_code=status_code, detail=error_message)\n        else:\n            raise HTTPException(status_code=500, detail="Failed to generate storage URL due to an unexpected internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_storage_url_endpoint: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected error occurred while generating the storage URL.")\n\n\n# Pydantic Models for Delete File From Supabase Storage\nclass DeleteFileStorageRequest(BaseModel):\n    bucket_name: str\n    storage_paths: List[str]\n\nclass FileErrorDetail(BaseModel):\n    path: str\n    error: str\n\nclass DeleteFileStorageData(BaseModel):\n    deleted_paths: List[str] = []\n    errors: List[FileErrorDetail] = []\n\nclass DeleteFileStorageResponse(BaseModel):\n    status: str\n    data: Optional[DeleteFileStorageData] = None\n    message: Optional[str] = None\n\n@router.post("/storage/delete", response_model=DeleteFileStorageResponse)\nasync def delete_files_from_storage_endpoint(request: DeleteFileStorageRequest):\n    try:\n        if not request.storage_paths:\n            raise HTTPException(status_code=400, detail="No storage paths provided for deletion.")\n        result = supabase_tools.delete_file_from_supabase_storage(\n            db_client=supabase,\n            bucket_name=request.bucket_name,\n            storage_paths=request.storage_paths\n        )\n        response_data = DeleteFileStorageData(\n            deleted_paths=result.get("deleted_paths", []),\n            errors=[FileErrorDetail(**err) for err in result.get("errors", [])]\n        )\n        current_status = "failure"\n        message = "Failed to delete one or more files."
        if response_data.deleted_paths and not response_data.errors:
            current_status = "success"
            message = "All specified files deleted successfully."
        elif response_data.deleted_paths and response_data.errors:
            current_status = "partial_success"
            message = "Some files were deleted, but errors occurred for others."
        elif not response_data.deleted_paths and not response_data.errors:
             message = "No files were processed or matched for deletion."


        return {"status": current_status, "data": response_data, "message": message}\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in delete_files_from_storage_endpoint: {e}")\n        error_data = DeleteFileStorageData(errors=[FileErrorDetail(path="all_paths", error=str(e))])\n        # Return a 500 with a structured error in the data field\n        return {"status": "failure", "data": error_data, "message": "An unexpected server error occurred."}\n\n\n# Pydantic Models for Manage User MFA Status\nclass ManageUserMfaStatusRequest(BaseModel):\n    action: str\n    factor_id: Optional[str] = None\n\nclass MfaFactorDetail(BaseModel):\n    id: str\n    status: str\n    factor_type: str\n    friendly_name: Optional[str] = None\n    created_at: Optional[str] = None\n\nclass ManageUserMfaStatusResponseData(BaseModel):\n    factors: Optional[List[MfaFactorDetail]] = None\n    detail: Optional[Dict[str, Any]] = None\n\nclass ManageUserMfaStatusResponse(BaseModel):\n    status: str\n    message: str\n    data: Optional[ManageUserMfaStatusResponseData] = None\n\n@router.post("/users/{user_id}/mfa", response_model=ManageUserMfaStatusResponse)\nasync def manage_user_mfa_endpoint(user_id: str, request: ManageUserMfaStatusRequest):\n    try:\n        result = supabase_tools.manage_user_mfa_status(\n            db_client=supabase, user_id=user_id, action=request.action, factor_id=request.factor_id\n        )\n        response_status = result.get("status", "error")\n        response_message = result.get("message", "An error occurred.")\n        response_data_payload = result.get("data")\n        mfa_data = None\n        if response_status == "success" or response_status == "conceptual":\n            if request.action == "list_factors" and isinstance(response_data_payload, list):\n                mfa_data = ManageUserMfaStatusResponseData(factors=[MfaFactorDetail(**f) for f in response_data_payload])\n            elif response_data_payload:\n                mfa_data = ManageUserMfaStatusResponseData(detail=response_data_payload)\n        
        if response_status == "error":\n            status_code = 400 if "required" in response_message or "Unsupported" in response_message else 500\n            # Create a detail dictionary for the HTTPException\n            error_detail_dict = {"status": response_status, "message": response_message}\n            if mfa_data: # Include data if available, even in error cases for context\n                error_detail_dict["data"] = mfa_data.model_dump(exclude_none=True)\n            raise HTTPException(status_code=status_code, detail=error_detail_dict)\n
        return {"status": response_status, "message": response_message, "data": mfa_data}\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in manage_user_mfa_endpoint for user {user_id}, action {request.action}: {e}")\n        raise HTTPException(status_code=500, detail={"status": "error", "message": "An unexpected server error occurred.", "data": None})\n\n\n# Pydantic Models for Revoke Supabase User Session\nclass RevokeUserSessionRequest(BaseModel):\n    scope: str = "all"\n\nclass RevokeUserSessionResponse(BaseModel):\n    status: str\n    message: str\n\n@router.post("/users/{user_id}/sessions/revoke", response_model=RevokeUserSessionResponse)\nasync def revoke_user_session_endpoint(user_id: str, request: RevokeUserSessionRequest):\n    try:\n        result = supabase_tools.revoke_supabase_user_session(\n            db_client=supabase, user_id=user_id, scope=request.scope\n        )\n        response_status = result.get("status", "error")\n        response_message = result.get("message", "An error occurred during session revocation.")\n        if response_status == "error":\n            status_code = 400 if "Unsupported scope" in response_message else 500\n            raise HTTPException(status_code=status_code, detail=response_message)\n        return {"status": response_status, "message": response_message}\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in revoke_user_session_endpoint for user {user_id}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected error occurred during session revocation.")\n\n\n# Pydantic Models for App Secrets (Supabase Vault - Conceptual)\nclass GetAppSecretResponseData(BaseModel):\n    secret_name: str\n    value: Optional[str] = None\n    error: Optional[str] = None\n\nclass GetAppSecretResponse(BaseModel):\n    status: str\n    data: Optional[GetAppSecretResponseData] = None\n    message: Optional[str] = None\n\n@router.get("/secrets/app/{secret_name}", response_model=GetAppSecretResponse)\nasync def get_app_secret_endpoint(secret_name: str):\n    try:\n        result = supabase_tools.get_app_secret(db_client=supabase, secret_name=secret_name)\n        if result and result.get("value"):\n            return {"status": "success", "data": GetAppSecretResponseData(secret_name=secret_name, value=result.get("value")), "message": "Secret retrieved successfully."}\n        elif result and result.get("error"):
             # For "not found" type errors from the tool, return 404\n            if "not found" in result.get("error", "").lower():\n                raise HTTPException(status_code=404, detail={"status": "error", "data": GetAppSecretResponseData(secret_name=secret_name, error=result.get("error")), "message": result.get("error")})\n            return {"status": "error", "data": GetAppSecretResponseData(secret_name=secret_name, error=result.get("error")), "message": result.get("error")}\n        else:\n            return {"status": "conceptual", "data": GetAppSecretResponseData(secret_name=secret_name), "message": "Secret retrieval is conceptual or secret not found."}\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_app_secret_endpoint for secret {secret_name}: {e}")\n        # For unexpected errors, ensure the response structure is consistent\n        error_data = GetAppSecretResponseData(secret_name=secret_name, error=str(e))\n        return {"status": "error", "data": error_data, "message": "An unexpected server error occurred."}\n\n\nclass SetAppSecretRequest(BaseModel):\n    secret_value: str\n\nclass SetAppSecretResponse(BaseModel):\n    status: str\n    message: str\n\n@router.post("/secrets/app/{secret_name}", response_model=SetAppSecretResponse)\nasync def set_app_secret_endpoint(secret_name: str, request: SetAppSecretRequest):\n    try:\n        result = supabase_tools.set_app_secret(db_client=supabase, secret_name=secret_name, secret_value=request.secret_value)\n        response_status = result.get("status", "error")\n        response_message = result.get("message", "An error occurred while setting the secret.")\n        if response_status == "error":\n             raise HTTPException(status_code=500, detail=response_message)\n        return {"status": response_status, "message": response_message}\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in set_app_secret_endpoint for secret {secret_name}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred while setting the secret.")\n\n\n# Pydantic Models for Get Translations\nclass GetTranslationsResponseData(BaseModel):\n    locale: str\n    namespace: str\n    translations: Dict[str, str]\n\nclass GetTranslationsResponse(BaseModel):\n    status: str\n    data: Optional[GetTranslationsResponseData] = None\n    message: Optional[str] = None\n\n@router.get("/translations/{locale}/{namespace}", response_model=GetTranslationsResponse)\nasync def get_translations_endpoint(locale: str, namespace: str):\n    try:\n        translations_map = supabase_tools.get_translations(db_client=supabase, locale=locale, namespace=namespace)\n        if translations_map is not None:\n            return {\n                "status": "success", \n                "data": GetTranslationsResponseData(locale=locale, namespace=namespace, translations=translations_map),\n                "message": "Translations retrieved successfully." if translations_map else "No translations found for the given locale and namespace."
            }\n        else:\n            raise HTTPException(status_code=500, detail=f"Failed to retrieve translations for {locale}/{namespace} due to an internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_translations_endpoint for {locale}/{namespace}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred while fetching translations.")\n\n\n# Pydantic Models for RPC Call\nclass RpcCallRequest(BaseModel):\n    function_name: str\n    params_dict: Optional[Dict[str, Any]] = None\n\nclass RpcCallResponse(BaseModel):\n    status: str\n    data: Optional[Any] = None\n    message: Optional[str] = None\n\n@router.post("/rpc", response_model=RpcCallResponse)\nasync def rpc_call_endpoint(request: RpcCallRequest):\n    try:\n        rpc_data = supabase_tools.rpc_call(\n            db_client=supabase,\n            function_name=request.function_name,\n            params_dict=request.params_dict\n        )\n        if rpc_data is not None: # Assumes tool returns data on success, None on specific handled errors\n            return {"status": "success", "data": rpc_data, "message": f"RPC function '{request.function_name}' executed successfully."}\n        else: # Tool logged an error and returned None\n            # It's better if the tool raises specific exceptions or returns an error structure\n            raise HTTPException(status_code=500, detail=f"Error executing RPC function '{request.function_name}'. Check server logs for details from the tool.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in rpc_call_endpoint for function {request.function_name}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred during RPC call.")\n\n\n# Pydantic Models for Get Cron Job Run Details\nclass CronJobRunDetail(BaseModel):\n    jobid: Optional[int] = None\n    runid: int\n    job_name: Optional[str] = None\n    database: Optional[str] = None\n    username: Optional[str] = None\n    command: Optional[str] = None\n    status: Optional[str] = None\n    return_message: Optional[str] = None\n    start_time: Optional[Any] = None\n    end_time: Optional[Any] = None\n\nclass GetCronJobRunDetailsResponse(BaseModel):\n    status: str\n    data: Optional[List[CronJobRunDetail]] = None\n    message: Optional[str] = None\n\n@router.get("/cron/runs", response_model=GetCronJobRunDetailsResponse)\nasync def get_cron_runs_endpoint(\n    limit: int = Query(10, ge=1, le=100), \n    job_name: Optional[str] = Query(None, alias="jobName"),\n    status: Optional[str] = Query(None)\n):\n    try:\n        run_details = supabase_tools.get_cron_job_run_details(\n            db_client=supabase, limit=limit, job_name_filter=job_name, status_filter=status\n        )\n        if run_details is not None:\n            return {\n                "status": "success", \n                "data": run_details,\n                "message": "Cron job run details retrieved successfully."
            }\n        else:\n            raise HTTPException(status_code=500, detail="Failed to retrieve cron job run details due to an internal error.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_cron_runs_endpoint: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred while fetching cron job run details.")\n\n\n# Pydantic Models for Invoke Supabase Function (General)\nclass InvokeSupabaseFunctionRequest(BaseModel):\n    function_name: str\n    body_payload: Dict[str, Any]\n    headers_dict: Optional[Dict[str, str]] = None\n\nclass InvokeSupabaseFunctionResponseData(BaseModel):\n    function_name: str\n    response_data: Optional[Any] = None\n    error: Optional[str] = None\n\nclass InvokeSupabaseFunctionResponse(BaseModel):\n    status: str\n    data: Optional[InvokeSupabaseFunctionResponseData] = None\n    message: Optional[str] = None\n\n@router.post("/functions/general/invoke", response_model=InvokeSupabaseFunctionResponse)\nasync def invoke_general_supabase_function_endpoint(request: InvokeSupabaseFunctionRequest):\n    try:\n        function_response_content = supabase_tools.invoke_supabase_function(\n            db_client=supabase,\n            function_name=request.function_name,\n            body_payload=request.body_payload,\n            headers_dict=request.headers_dict\n        )\n        if function_response_content is not None:\n            # Assuming function_response_content is the direct response or an error dict from the function\n            if isinstance(function_response_content, dict) and function_response_content.get("error"):
                 error_detail = str(function_response_content.get("error"))
                 return {"status": "failure", "data": InvokeSupabaseFunctionResponseData(function_name=request.function_name, error=error_detail), "message": f"Function '{request.function_name}' invoked but returned an error: {error_detail}"}\n
            return {"status": "success", "data": InvokeSupabaseFunctionResponseData(function_name=request.function_name, response_data=function_response_content), "message": f"Function '{request.function_name}' invoked successfully."}\n        else:\n            response_data_obj = InvokeSupabaseFunctionResponseData(function_name=request.function_name, error="Tool failed to invoke Supabase function or function returned no data.")\n            raise HTTPException(status_code=502, detail={"status": "failure", "data": response_data_obj, "message": f"Failed to invoke Supabase function '{request.function_name}' or function returned no data."})\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in invoke_general_supabase_function_endpoint for {request.function_name}: {e}")\n        response_data_obj = InvokeSupabaseFunctionResponseData(function_name=request.function_name, error=str(e))\n        raise HTTPException(status_code=500, detail={"status": "failure", "data": response_data_obj, "message": "An unexpected server error occurred."})\n\n\n# Pydantic Models for Invoke Edge Function\nclass InvokeEdgeFunctionRequest(BaseModel):\n    payload: Dict[str, Any]\n\nclass InvokeEdgeFunctionResponseData(BaseModel):\n    function_name: str\n    response_data: Optional[Any] = None\n    error: Optional[str] = None\n\nclass InvokeEdgeFunctionResponse(BaseModel):\n    status: str\n    data: Optional[InvokeEdgeFunctionResponseData] = None\n    message: Optional[str] = None\n\n@router.post("/realtime/v1/event")\nasync def realtime_event(request: Request):\n    data = await request.json()\n    try:\n        # TODO: Define supabase_tools.handle_realtime_event or remove/update this endpoint\n        result = supabase_tools.handle_realtime_event(data) # This function is not in task-master\n        return {"status": "success", "data": result}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.post("/storage/v1/manage")\nasync def manage_storage(request: Request):\n    data = await request.json()\n    try:\n        action = data.get("action")\n        bucket = data.get("bucket")\n        path = data.get("path")\n        file_data = data.get("data") # Assuming data is sent in the request body\n        result = supabase_tools.manage_storage_object(action, bucket, path, file_data)\n        return {"status": "success", "data": result}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.post("/edge-functions/v1/invoke/{function_name}", response_model=InvokeEdgeFunctionResponse)\nasync def invoke_edge_function_endpoint(function_name: str, request_payload: InvokeEdgeFunctionRequest):\n    """\n    API endpoint to invoke a Supabase Edge Function.\n    """\n    try:\n        edge_function_response_content = supabase_tools.invoke_edge_function(\n            db_client=supabase,\n            function_name=function_name,\n            payload=request_payload.payload\n        )\n        if edge_function_response_content is not None:\n            if isinstance(edge_function_response_content, dict) and edge_function_response_content.get("error"):
                error_detail = str(edge_function_response_content.get("error"))
                # Consider if this should be a 5xx or if the client should parse the 'error' in data\n                return {"status": "success", "data": InvokeEdgeFunctionResponseData(function_name=function_name, response_data=None, error=error_detail), "message": f"Edge function '{function_name}' invoked but returned an error."}\n
            return {"status": "success", "data": InvokeEdgeFunctionResponseData(function_name=function_name, response_data=edge_function_response_content), "message": f"Edge function '{function_name}' invoked successfully."}\n        else:\n            response_data_obj = InvokeEdgeFunctionResponseData(function_name=function_name, error="Tool failed to invoke edge function or function returned no data.")\n            raise HTTPException(status_code=502, detail={"status": "failure", "data": response_data_obj, "message": f"Failed to invoke edge function '{function_name}' or function returned no data."})\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in invoke_edge_function_endpoint for {function_name}: {e}")\n        response_data_obj = InvokeEdgeFunctionResponseData(function_name=function_name, error=str(e))\n        raise HTTPException(status_code=500, detail={"status": "failure", "data": response_data_obj, "message": "An unexpected server error occurred."})\n
# Pydantic Models for Generic Table Data Operations\nclass FilterItem(BaseModel):\n    column: str\n    operator: str \n    value: Any\n\nclass GetTableDataResponse(BaseModel):\n    status: str\n    data: Optional[Any] = None \n    message: Optional[str] = None\n    count: Optional[int] = None\n\n@router.post("/auth/v1/authenticate")\nasync def authenticate(request: Request):\n    data = await request.json()\n    try:\n        # TODO: Define supabase_tools.authenticate_user or remove/update this endpoint\n        result = supabase_tools.authenticate_user(data) # This function is not in task-master\n        return {"status": "success", "data": result}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get("/data/{table_name}", response_model=GetTableDataResponse)\nasync def get_table_data_endpoint(\n    table_name: str,\n    select_columns: str = Query("*", alias="selectColumns"),\n    filters_json: Optional[str] = Query(None, alias="filters"), \n    order_by: Optional[str] = Query(None, alias="orderBy"),\n    order_desc: bool = Query(False, alias="orderDesc"),\n    limit: Optional[int] = Query(None, ge=1),\n    single: bool = Query(False),\n):\n    """\n    Generic API endpoint to fetch data from a specified table with filtering, sorting, and pagination.\n    'filters_json' should be a URL-encoded JSON string array of filter objects:\n    e.g., `[{"column":"name","operator":"like","value":"%test%"}, {"column":"status","operator":"eq","value":"active"}]`\n    """\n    import json \n    parsed_filters: Optional[List[Dict[str, Any]]] = None\n    if filters_json:\n        try:\n            parsed_filters = json.loads(filters_json)\n            if not isinstance(parsed_filters, list):\n                raise ValueError("Filters must be a JSON array of filter objects.")\n        except json.JSONDecodeError:\n            raise HTTPException(status_code=400, detail="Invalid JSON format for filters.")\n        except ValueError as ve:\n            raise HTTPException(status_code=400, detail=str(ve))\n\n    try:\n        data = supabase_tools.get_table_data(\n            db_client=supabase,\n            table_name=table_name,\n            select_columns=select_columns,\n            filters_list=parsed_filters,\n            order_by=order_by,\n            order_desc=order_desc,\n            limit=limit,\n            single=single\n        )\n        if data is not None:\n            return {"status": "success", "data": data, "message": "Data retrieved successfully."}\n        else:\n            if single: \n                 return {"status": "success", "data": None, "message": "Record not found."}\n            raise HTTPException(status_code=500, detail=f"Failed to retrieve data from table '{table_name}'. Check server logs.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in get_table_data_endpoint for table {table_name}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred.")\n
# Pydantic model for InsertTableData\nclass InsertDataRequest(BaseModel):\n    data: Union[Dict[str, Any], List[Dict[str, Any]]]\n\nclass InsertDataResponse(BaseModel):\n    status: str\n    data: Optional[List[Dict[str, Any]]] = None\n    message: Optional[str] = None\n\n@router.post("/data/{table_name}", response_model=InsertDataResponse)\nasync def insert_table_data_endpoint(table_name: str, request_body: InsertDataRequest):\n    """\n    Generic API endpoint to insert one or more rows into a specified table.\n    """\n    try:\n        inserted_data = supabase_tools.insert_table_data(\n            db_client=supabase,\n            table_name=table_name,\n            data_to_insert=request_body.data\n        )\n        if inserted_data is not None: \n            return {"status": "success", "data": inserted_data, "message": "Data inserted successfully."}\n        else:\n            raise HTTPException(status_code=500, detail=f"Failed to insert data into table '{table_name}'. Check server logs.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in insert_table_data_endpoint for table {table_name}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred.")\n
# Pydantic model for UpdateTableData\nclass UpdateTableDataRequest(BaseModel):\n    data_to_update: Dict[str, Any]\n    filters_list: List[FilterItem] \n\nclass UpdateDataResponse(BaseModel): \n    status: str\n    data: Optional[List[Dict[str, Any]]] = None\n    message: Optional[str] = None\n\n@router.put("/data/{table_name}", response_model=UpdateDataResponse)\nasync def update_table_data_endpoint(table_name: str, request_body: UpdateTableDataRequest):\n    """\n    Generic API endpoint to update rows in a specified table based on filters.\n    """\n    if not request_body.filters_list:\n        raise HTTPException(status_code=400, detail="filters_list cannot be empty for an update operation to prevent accidental full table updates.")\n    try:\n        updated_data = supabase_tools.update_table_data(\n            db_client=supabase,\n            table_name=table_name,\n            data_to_update=request_body.data_to_update,\n            filters_list=request_body.filters_list\n        )\n        if updated_data is not None: \n            if not updated_data: \n                return {"status": "success", "data": [], "message": "No records updated. Filters might not have matched any rows or data was identical."}\n            return {"status": "success", "data": updated_data, "message": "Data updated successfully."}\n        else:\n            raise HTTPException(status_code=500, detail=f"Failed to update data in table '{table_name}'. Check server logs.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in update_table_data_endpoint for table {table_name}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred.")\n
# Pydantic model for DeleteTableData\nclass DeleteTableDataRequest(BaseModel):\n    filters_list: List[FilterItem] \n\nclass DeleteDataResponse(BaseModel): \n    status: str\n    data: Optional[List[Dict[str, Any]]] = None\n    message: Optional[str] = None\n\n@router.delete("/data/{table_name}", response_model=DeleteDataResponse)\nasync def delete_table_data_endpoint(table_name: str, request_body: DeleteTableDataRequest):\n    """\n    Generic API endpoint to delete rows from a specified table based on filters.\n    """\n    if not request_body.filters_list:\n        raise HTTPException(status_code=400, detail="filters_list cannot be empty for a delete operation to prevent accidental full table deletions.")\n    try:\n        deleted_data = supabase_tools.delete_table_data(\n            db_client=supabase,\n            table_name=table_name,\n            filters_list=request_body.filters_list\n        )\n        if deleted_data is not None: \n            if not deleted_data: \n                 return {"status": "success", "data": [], "message": "No records deleted. Filters might not have matched any rows."}\n            return {"status": "success", "data": deleted_data, "message": "Data deleted successfully."}\n        else:\n            raise HTTPException(status_code=500, detail=f"Failed to delete data from table '{table_name}'. Check server logs.")\n    except HTTPException as http_exc:\n        raise http_exc\n    except Exception as e:\n        print(f"Error in delete_table_data_endpoint for table {table_name}: {e}")\n        raise HTTPException(status_code=500, detail="An unexpected server error occurred.")\n
