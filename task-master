# SEED-MCP: Tool Requirements and Implementation Plan

This document outlines the required Model Context Protocol (MCP) tools for the SEED project, derived from an analysis of the SEED Outline documents. It will be updated incrementally as each section of the SEED Outline is reviewed.

## Analysis of SEED Outline Sections

### Section 1 pt I: SEED Design System

**1. Key Functionalities Identified:**
    - Tenant-specific theming (colors, typography) loaded from Supabase.
    - Logging of various UI events (theme application, button clicks, input changes, modal closures, AI interactions, toast displays, animation triggers) to Supabase.
    - Tenant-specific form validation rules fetched from Supabase.
    - Tenant-specific table column configurations fetched from Supabase.
    - AI-driven input suggestions for UI components, fetched via an `agentRunner`.
    - Client-side offline support for UI actions (`OfflineMutationManager`), potentially requiring server-side processing of queued mutations.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
        - `get_tenant_theme(tenant_id)`: Fetches theme data (colors, typography).
        - `log_ui_event(tenant_id, event_type, payload)`: Logs UI events.
        - `get_tenant_validation_rules(tenant_id)`: Fetches form validation rules.
        - `get_tenant_table_config(tenant_id)`: Fetches table column configurations.
        - `get_tenant_icon_set_config(tenant_id)` (Potential): For tenant-specific icon sets if managed via Supabase.
        - `get_tenant_grid_config(tenant_id)` (Potential): For tenant-specific grid configurations if managed via Supabase.

    b. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - `get_ai_input_suggestions(tenant_id, current_input_context)`: Interacts with `agentRunner` (e.g., 'WorkflowOptimizer' agent) to fetch input suggestions.

    c. **Offline-First Sync Tools (`tools/offline_sync/offline_sync_tools.py`)** (Potential - depends on offline architecture)
        - `process_offline_mutation_batch(mutations)`: Processes a batch of client-queued mutations.

**3. High-Level Implementation Notes (MCP Perspective):**
    - Define/confirm Supabase table schemas for `tenant_themes`, `ui_events`, `tenant_validation_rules`, `tenant_table_configs`.
    - Implement the Python functions listed above within their respective `_tools.py` files, using the Supabase client for database operations and appropriate methods for agent interaction.
    - Ensure secure data handling, parameter sanitization, and robust error responses.
    - Expose these tool functions through the corresponding FastAPI routers (e.g., `seed-supabase.py`, `seed-ai_agents.py`).

### Section 1 pt II: SEED Design System (Continued - UI Patterns & Accessibility)

**1. Key Functionalities Identified:**
    - Consistent loading state management (`useLoadingState` hook) with UI event logging to Supabase.
    - Reusable drag-and-drop functionality (`useDragDrop` hook) with UI event logging to Supabase.
    - AI interaction elements (`AiThinkingIndicator`, `AiSuggestedActions`) with UI event logging and `agentRunner` interaction for suggestions.
    - Comprehensive accessibility features (Keyboard Navigation, Screen Reader announcements, Color Contrast utilities, Text Resizability, Alt Text utilities).
    - UI event logging to Supabase for accessibility-related events (focus changes, input modality, screen reader announcements, contrast checks, alt text validation, text zoom changes).
    - Fetching tenant-specific accessibility configurations from Supabase.
    - AI-driven alt text generation for images via `agentRunner`.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
        - `log_ui_event(tenant_id, event_type, payload)`: (Reinforced) Heavily used for logging various UI and accessibility events.
        - `get_tenant_accessibility_config(tenant_id)`: Fetches accessibility configurations (contrast level, font preferences, alt text guidelines).

    b. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - `get_ai_suggested_actions(tenant_id, current_context)`: Interacts with `agentRunner` (e.g., 'ActionSuggester' agent) to fetch suggested UI actions.
        - `generate_ai_alt_text(image_url, image_type, tenant_id)`: Interacts with `agentRunner` (e.g., 'AltTextGenerator' agent) to generate alt text for images.

**3. High-Level Implementation Notes (MCP Perspective):**
    - Ensure `log_ui_event` is robust enough to handle a wide variety of event types and payloads from the design system components.
    - Define/confirm Supabase table schema for `tenant_accessibility`.
    - Implement the new functions in their respective `_tools.py` files.
    - Expose these functions via FastAPI routers.

### Section 2: Technical Infrastructure Enhancements

**1. Key Functionalities Identified:**
    - **Advanced Queueing (RabbitMQ):** Tenant-specific priority queues, DLQs, dynamic batch sizing, AI-driven event prioritization.
    - **Aggressive Caching (In-memory & Redis):** Multi-layered, tenant-isolated caching, AI-driven TTL optimization, Supabase Realtime for cache invalidation.
    - **Database Optimization (PostgreSQL & pgvector):** Tenant-scoped indexes, AI-driven HNSW tuning, tenant-specific table partitioning, read replica routing.
    - **Stateless & Optimized Services:** Tenant-specific service configurations (potentially AI-optimized), service profiling, metrics logging.
    - **System Event/Metric Logging:** Logging various infrastructure-related events and metrics to Supabase.
    - **AI Agent Usage:** For optimizing queue priority, cache TTLs, HNSW parameters, and service configurations.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Message Queue Interaction Tools (NEW - `tools/message_queues/message_queue_tools.py`)**
        - `initialize_tenant_rabbitmq_queue(tenant_id)`: Sets up tenant-specific queues, DLQs, and exchanges.
        - `publish_to_rabbitmq_queue(tenant_id, event_payload, urgency_level)`: Publishes event, potentially using AI agent for dynamic priority.
        - `get_rabbitmq_queue_depth(tenant_id, queue_name)`: Retrieves current queue depth.
        - `process_rabbitmq_batch(tenant_id)` (Note: May be an internal function for workers rather than a direct MCP tool).

    b. **Caching Interaction Tools (NEW - `tools/caching/caching_tools.py`)**
        - `get_cached_item(tenant_id, cache_key)`: Retrieves item from multi-layer cache (in-memory, Redis).
        - `set_cached_item(tenant_id, cache_key, item_data, custom_ttl=None)`: Sets item in cache, potentially using AI agent for TTL.
        - `invalidate_cache_key(tenant_id, cache_key_pattern)`: Invalidates cache entries.

    c. **Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
        - `log_system_event(tenant_id, event_type, payload)`: For infrastructure events (queue init, cache invalidation, index creation, etc.).
        - `log_system_metric(tenant_id, metric_name, value_payload)`: For infrastructure metrics (queue stats, cache stats, query stats, etc.).
        - `get_tenant_service_config(tenant_id)`: Fetches configuration for stateless services.

    d. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
        - `create_pg_tenant_index(tenant_id, table_name, column_names, index_type)`: Creates tenant-specific PostgreSQL indexes.
        - `tune_pg_hnsw_index(tenant_id, index_name, ef_construction, m)`: Tunes pgvector HNSW index parameters.
        - `create_pg_tenant_partition(tenant_id, table_name, partition_logic_details)`: Creates tenant-specific table partitions.
        - `execute_pg_query(tenant_id, query_text, params, use_replica=True)`: (Enhanced) Executes PostgreSQL query with explicit read replica option.

    e. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - `predict_event_priority(tenant_id, event_details)`: For `QueueOptimizer`.
        - `predict_cache_ttl(tenant_id, cache_key_details)`: For `CacheOptimizer`.
        - `predict_hnsw_params(tenant_id, table_name)`: For `DatabaseOptimizer`.
        - `predict_service_config(tenant_id, service_name, current_config)`: For `ServiceOptimizer`.

    f. **System Command Execution Tools (Existing `execute_command`)**
        - Potentially for triggering service profiling scripts (e.g., `clinic doctor`), though this might be more of a DevOps task.

**3. High-Level Implementation Notes (MCP Perspective):**
    - Create new tool modules for Message Queues and Caching if they don't exist.
    - Implement functions to interact with RabbitMQ (e.g., using `aio_pika` or `pika`).
    - Implement functions to interact with Redis (e.g., using `redis-py`).
    - Extend database tools for specific DDL operations (indexes, partitions) and HNSW tuning.
    - Ensure all AI agent interactions are routed through the generic AI agent tool functions.
    - Define schemas for new Supabase tables: `system_logs`, `system_metrics`, `tenant_services_config`.

### Section 3: Core Operational & Supporting Schema (PostgreSQL + Supabase OSS)

**1. Key Functionalities Identified:**
    - **Database Schema:** Defines numerous tables for core operations (tenants, users, leads, clients, bookings, interactions), agent operations (agent_logs, workflow_definitions, workflow_runs, agent_memory_embeddings, agent_configs), analytics, file metadata, and system/audit logs.
    - **Multi-Tenancy & RLS:** Heavy emphasis on `tenant_id` in all relevant tables and enforcement via PostgreSQL Row Level Security.
    - **Supabase Stack Integration:** Uses Supabase Auth, Realtime, Storage, Edge Functions, and Supavisor.
    - **Vector Storage (pgvector):** `agent_memory_embeddings` table uses pgvector for AI memory.
    - **File Storage:** Metadata in `files` table, blobs in S3-compatible storage via Supabase Storage.
    - **Workflow Engine Support:** Tables `workflow_definitions` and `workflow_runs` support a workflow engine.
    - **Configuration Management:** `agent_configs` table for JSON schemas and agent-specific configurations.
    - **Logging:** Extensive logging to `system_logs`, `audit_logs`, and `agent_logs`.
    - **Billing & Usage Tracking:** `billing_usage` and `billing_tokens` tables.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
        - **Generic CRUD:** `execute_pg_query` (SELECT, INSERT, UPDATE, DELETE for various tables), `execute_pg_transaction`.
        - **Schema Management (DDL):**
            - `manage_pg_enum_type(action, type_name, values)`
            - `manage_pg_table(action, table_definition)` (general DDL)
            - `manage_pg_rls_policy(action, table_name, policy_name, policy_definition)`
        - **Vector DB (pgvector specific):**
            - `insert_pg_vector_embedding(tenant_id, entity_type, entity_id, embedding, metadata, source_text_hash, source_text, priority)`
            - `search_pg_vector_embeddings(tenant_id, query_vector, filters, top_k)`
            - `update_pg_vector_embedding_access(tenant_id, embedding_id, access_timestamp)` (for `last_accessed_at`, `retrieval_count`)
            - `run_pg_vector_gc_job(tenant_id)` (embedding garbage collection)
        - **Specific Table Operations (examples):**
            - `get_user_by_auth_id(auth_id)`
            - `create_lead(tenant_id, lead_data)`
            - `get_bookings_for_staff(tenant_id, staff_id, time_range)`
            - `log_interaction(tenant_id, interaction_data)`
            - `log_agent_execution(tenant_id, agent_log_data)` (for `agent_logs`)
            - `log_billing_token_usage(tenant_id, token_usage_data)` (for `billing_tokens`)
            - `get_file_metadata(tenant_id, file_id_or_path)`
            - `create_file_metadata(tenant_id, file_metadata)`
            - `delete_file_metadata(tenant_id, file_id)` (must also trigger blob deletion)

    b. **Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
        - `manage_supabase_user(action, user_details)` (e.g., create user in `auth.users` and link to `public.users`)
        - `get_file_storage_url(action, tenant_id, file_path, content_type=None)` (for upload/download presigned URLs)
        - `delete_file_from_supabase_storage(tenant_id, storage_path)` (called by DB tool or directly)
        - `invoke_edge_function(function_name, payload)` (reconfirmed, e.g., for dynamic partition creation)

    c. **Workflow Management Tools (`tools/workflow_management/workflow_management_tools.py`)**
        - `create_workflow_definition(tenant_id, name, description, trigger_type, trigger_config, structure_json)`
        - `update_workflow_definition(tenant_id, workflow_def_id, updates_json)`
        - `get_workflow_definition(tenant_id, workflow_def_id)`
        - `activate_workflow_definition(tenant_id, workflow_def_id, is_active_flag)`
        - `trigger_workflow_run(tenant_id, workflow_def_id, trigger_event_data, input_context)`
        - `get_workflow_run_details(tenant_id, workflow_run_id)`
        - `update_workflow_run(tenant_id, workflow_run_id, status, current_step_id, steps_state_updates, error_log_updates)`

    d. **Settings Management Tools (`tools/settings_management/settings_management_tools.py`)**
        - `get_agent_config_value(tenant_id, agent_name, config_key, version_tag=None)`
        - `set_agent_config_value(tenant_id, agent_name, config_key, config_value, version_tag=None, description=None)`
        - `manage_json_schema(action, schema_name, version, schema_definition_json)` (for `agent_configs` table storing JSON schemas)
        - `get_tenant_settings(tenant_id)` (from `tenants.settings` JSONB)
        - `update_tenant_settings(tenant_id, settings_payload)`

    e. **Agent Log Review Tools (`tools/agent_log_review/agent_log_review_tools.py`)**
        - `query_agent_logs(tenant_id, filters)` (e.g., by agent_name, status, time_range, related_entity)
        - `get_agent_log_details(tenant_id, agent_log_id)`
        - `submit_agent_log_feedback(tenant_id, agent_log_id, user_id, rating, comment)` (populates `agent_shadow_action_responses`)

**3. High-Level Implementation Notes (MCP Perspective):**
    - This section defines the bulk of the database interaction logic. MCP tools must provide a secure, tenant-aware abstraction layer.
    - RLS policies are critical and assumed to be handled at the DB level, but MCP tools must operate with user contexts that allow RLS to function correctly (e.g., passing JWT claims or setting session variables).
    - Encryption of sensitive data in JSONB fields (e.g., `agent_logs.input_payload`, `agent_configs.config_value`) needs to be handled, potentially within the MCP tool functions before DB insertion or after retrieval, using pgcrypto or application-level encryption with keys from a secrets manager.
    - For tables like `agent_memory_embeddings`, `interactions`, `agent_logs`, `system_logs`, `audit_logs`, which can grow very large, MCP tools should support efficient querying, possibly with pagination.
    - The `files` table metadata operations need to be coordinated with actual Supabase Storage blob operations.

### Section 4: Access Layer & API Orchestration

**1. Key Functionalities Identified:**
    - **Unified API Gateway:** Using Caddy/Traefik/NGINX for routing, TLS, and initial JWT validation.
    - **GraphQL API (Hasura):** Auto-generated schema, Realtime subscriptions, RLS enforcement via JWT claims. Custom resolvers/mutations via PG Functions or Hasura Actions.
    - **gRPC API (Buf + Connect-Go/Twirp):** Low-latency, structured contracts for AI agents, mobile apps, internal services. REST/JSON interface via gRPC Gateway. JWT authentication and RLS context setting. Streaming for bulk data/logs.
    - **WebSocket Layer (Supabase Realtime):** Realtime UI updates, agent console feeds, workflow event broadcasting. JWT authentication and RLS filtering.
    - **Edge Functions (Supabase):** Stateless logic for webhook handlers, agent/embedding triggers, presigned URL generation, public booking endpoints. JWT authentication or API key for internal, strict security for public.
    - **Standardized Error Structure & API Conventions:** Consistent error responses and conventions for pagination, filtering, sorting across API layers.
    - **API Security (Zero-Trust):** JWT validation, RLS context setting, input validation, output encoding, rate limiting, session management.
    - **Schema Governance & Versioning:** Strategies for gRPC, GraphQL, REST, Edge Functions, and JSON Schemas.
    - **AI/Agent Interaction:** Agents prefer gRPC or Edge Functions. GraphQL for exploration. WebSockets for real-time triggers.
    - **Monitoring Integration:** API layers capture metrics (latency, count, errors) for `system_metrics` or external systems.
    - **GraphQL Query for Agent Capabilities:** `agentUICapabilities` query to fetch agent manifests from `agent_registry`.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
        - `get_agent_registry_capabilities(agent_names_list)`: Fetches UI capabilities and other manifest data from `agent_registry` table to support the `agentUICapabilities` GraphQL query.
        - (Reinforced) Generic query execution (`execute_pg_query`) will be heavily used by gRPC service implementations and custom GraphQL resolvers (if implemented as PG functions).
        - (Reinforced) RLS policy management tools (`manage_pg_rls_policy`) are crucial for the security model described.

    b. **Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
        - `invoke_edge_function(function_name, payload)`: (Reinforced) Used for various tasks like webhook handling, agent triggers, presigned URL generation.
        - `get_file_storage_url(action, tenant_id, file_path, content_type=None)`: (Reinforced) For generating presigned URLs, likely called by an Edge Function.

    c. **Message Queue Interaction Tools (`tools/message_queues/message_queue_tools.py`)**
        - (Reinforced) Edge Functions acting as webhook handlers or agent triggers might publish events to RabbitMQ using these tools.

    d. **Workflow Management Tools (`tools/workflow_management/workflow_management_tools.py`)**
        - (Reinforced) Edge Functions or gRPC services might trigger workflows using these tools.

    e. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - (Reinforced) gRPC services and Edge Functions will be primary consumers of AI agent tools.

**3. High-Level Implementation Notes (MCP Perspective):**
    - MCP tools must be designed to be easily callable from gRPC service implementations and Supabase Edge Functions.
    - Tool functions should return data and errors in a way that aligns with the standardized API error structures and conventions (Section 4.7).
    - Ensure MCP tools operate correctly within the described Zero-Trust security model, relying on JWT claims and RLS context set by the calling API layers.
    - The implementation of `get_agent_registry_capabilities` needs to query the `agent_registry` table (schema details for this table might be in a later section or need to be assumed/defined).

### Section 5: Execution Pipeline & Orchestration Engine

**1. Key Functionalities Identified:**
    - **Event Bus (Redis Streams):** Standardized event publishing and consumption with persistence, consumer groups, and priority channels.
    - **Orchestrator Engine:** Consumes events, uses routing rules (from `event_routing_rules` table) to dispatch tasks to workflows or AI agents. Manages workflow state.
    - **Vector Bridge:** Retrieves context from vector stores (pgvector, Pinecone, Weaviate) to augment agent input payloads.
    - **Agent Runner Pool Coordination:** Uses `agent_registry` table for runner discovery and load balancing. Standardized agent execution contract.
    - **Agent Coordination Protocol (ACP):** Hybrid policy for conflict resolution using `hybrid_policy_configs` and logging to `acp_ledger`.
    - **Vector Index Tuning:** Bayesian optimization for HNSW parameters (`ef_search`, `m`), re-indexing based on data drift. Storing configs in `vector_policy_configs`.
    - **Federated Learning:** Differential privacy for model updates, secure aggregation (AWS Nitro Enclaves), robust algorithms, personalization. Uses `priority_models` and `global_priority_models` tables.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Message Queue Interaction Tools (`tools/message_queues/message_queue_tools.py`)**
        - `publish_to_redis_stream(stream_name, event_payload_dict)`: Publishes a standardized event.
        - `consume_from_redis_stream(stream_name, consumer_group, consumer_name, count, block_ms)`: Consumes events.
        - `acknowledge_redis_stream_message(stream_name, consumer_group, message_id)`: Acknowledges processed message.
        - (RabbitMQ functions remain if used for other purposes).

    b. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
        - `get_event_routing_rules(event_type, source_criteria)`: Fetches rules from `event_routing_rules`.
        - `get_agent_runner_details(agent_type_filter)`: Queries `agent_registry`.
        - `register_agent_runner_instance(runner_details)`: Adds/updates runner in `agent_registry`.
        - `get_acp_hybrid_policy_config(tenant_id)`: Fetches from `hybrid_policy_configs`.
        - `log_acp_ledger_entry(event_id, tenant_id, agent_id, task_id, resolution, explanation_json)`: Inserts into `acp_ledger`.
        - `get_vector_policy_config(tenant_id)`: Fetches from `vector_policy_configs` (new table).
        - `update_vector_policy_config(tenant_id, ef_search, m)`: Updates `vector_policy_configs`.
        - `get_priority_model_weight(tenant_id, agent_id, task_type)`: From `priority_models`.
        - `update_priority_model_weight(tenant_id, agent_id, task_type, weight)`: To `priority_models`.
        - `get_all_priority_models_for_aggregation()`: Fetches all tenant models.
        - `store_global_priority_model_weights(model_id, agent_id, task_type, weight)`: To `global_priority_models`.
        - (Reinforced) `search_pg_vector_embeddings` for Vector Bridge.
        - (Reinforced) CRUD for `workflow_runs`, `steps_state`.

    c. **Vector Database Interaction Tools (`tools/vector_databases/vector_databases_tools.py`)**
        - (Reinforced) `search_vectors` (pgvector, Pinecone, Weaviate) used by Vector Bridge.
        - `trigger_vector_reindex(database_type, collection_name_or_index_name)`: For data drift.

    d. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - `dispatch_agent_task_to_runner(runner_details, execution_contract)`: Sends task to a specific agent runner.
        - (Potentially) Specialized agent calls for Bayesian optimization or federated learning steps if these are managed by dedicated AI agents.

    e. **Settings Management Tools (`tools/settings_management/settings_management_tools.py`)**
        - (Reinforced) Managing configurations for ACP policies, vector tuning, federated learning if stored centrally.

    f. **Cloud Service Interaction Tools (NEW - `tools/cloud_services/aws_tools.py` or similar)**
        - `aggregate_with_nitro_enclave(data_to_aggregate, aggregation_config)`: For secure aggregation in federated learning.

**3. High-Level Implementation Notes (MCP Perspective):**
    - Implement robust Redis Streams interaction logic in `message_queue_tools.py`.
    - Define schemas and implement CRUD/query functions for new tables: `event_routing_rules`, `agent_registry`, `hybrid_policy_configs`, `acp_ledger`, `vector_policy_configs` (new), `priority_models`, `global_priority_models`.
    - The Vector Bridge logic will heavily rely on `vector_database_tools.py` and `database_tools.py`.
    - Orchestrator logic will use Message Queue, Database, AI Agent, and Workflow tools extensively.
    - If AWS Nitro Enclaves are used, a new tool category for AWS interactions will be needed.

### Section 6: Agent Learning, Evolution & Reward System

**1. Key Functionalities Identified:**
    - **Reward Signal Capture:** Extrinsic (user likes/dislikes/comments on agent outputs stored in `agent_logs` and `agent_shadow_action_responses`) and Intrinsic (system metrics like task success, latency, cost, conversion outcomes also in `agent_logs`).
    - **ReflectionAgent:** Analyzes aggregated logs and feedback, generates recommendations for prompt/config tuning, agent reranking, fallback agents, and training data candidates. Logs recommendations to `reflection_logs`. Performs bias drift checks.
    - **Reward Score Model:** Composite score calculated by ReflectionAgent using weighted metrics from `agent_learning_config`.
    - **Agent Memory & Context:** Short-term (Execution Contract, Redis) and Long-term (Vector Store - `agent_memory_embeddings` with TTL policy).
    - **Prompt Variant Management:** `agent_prompt_templates` table for A/B testing and evolution, including auto-retirement suggestions.
    - **`agent_learning_config` Table:** Stores agent-specific tuning parameters for learning loop.
    - **Agent Definition Schema (`agent_registry`):** Includes `ui_capabilities` and `pii_handling_capability`.
    - **Agent Execution Modes:** Standard, Dry Run, Debug, Deterministic, Vector Disabled, controlled by execution flags.
    - **Agent Versioning & Evolution Control:** Admin-approved workflow for applying ReflectionAgent recommendations.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
        - `update_agent_log_feedback_extrinsic(agent_log_id, user_id, feedback_rating, feedback_comment)`: Updates `agent_logs`.
        - `update_agent_log_metrics_intrinsic(agent_log_id, metrics_payload)`: Updates `agent_logs`.
        - `query_agent_logs_for_reflection_analysis(query_parameters)`: Fetches data for ReflectionAgent.
        - `flag_agent_log_as_finetune_candidate(agent_log_id, is_candidate, reason)`: Updates `agent_logs`.
        - `log_reflection_agent_output(reflection_run_id, recommendations_payload, bias_check_results)`: Inserts into `reflection_logs` (new table).
        - `get_agent_learning_config_data(agent_name)`: Fetches from `agent_learning_config`.
        - `update_agent_learning_config_data(agent_name, config_updates)`: Updates `agent_learning_config`.
        - `get_agent_prompt_template_details(prompt_id_or_name, version_tag=None)`: From `agent_prompt_templates`.
        - `create_new_agent_prompt_template(template_data)`: Inserts into `agent_prompt_templates`.
        - `update_existing_agent_prompt_template(prompt_id, updates_payload)`: Updates `agent_prompt_templates` (e.g., `is_active`, `approved_by_admin`, `avg_reward_score`).
        - `get_active_agent_prompt(agent_name)`: Fetches current active/approved prompt.
        - `update_agent_memory_embedding_expiry(embedding_id, expires_at_timestamp)`: For `agent_memory_embeddings`.
        - (Reinforced) `get_agent_definition` and `update_agent_definition` for `agent_registry` to manage `ui_capabilities`, `pii_handling_capability`, `active_prompt_template_id`, `current_stable_version`.

    b. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - `invoke_reflection_agent(trigger_payload)`: Triggers the ReflectionAgent's analysis cycle.
        - (Potentially) `trigger_llm_finetuning_pipeline(model_provider_details, dataset_reference, new_model_identifier)`: If an external fine-tuning process is managed.

    c. **Settings Management Tools (`tools/settings_management/settings_management_tools.py`)**
        - (Reinforced) CRUD operations for `agent_learning_config` and `agent_prompt_templates` can be seen as settings.

    d. **Workflow Management Tools (`tools/workflow_management/workflow_management_tools.py`)**
        - `trigger_admin_approval_workflow(recommendation_id, recommendation_details)`: For ReflectionAgent's suggestions.
        - `update_system_config_after_approval(approved_change_details)`: Called by workflow upon admin approval to apply changes (e.g., update prompt, agent config).

**3. High-Level Implementation Notes (MCP Perspective):**
    - Define schemas for new tables: `reflection_logs`, `agent_prompt_templates`. (Schema for `agent_learning_config` is provided in Sec 6.7).
    - Implement extensive new DB tool functions for managing agent learning configurations, prompt versions, and reflection logs.
    - The ReflectionAgent (itself an AI agent) will be a consumer of many DB and AI Agent tools.
    - The admin approval workflow for agent evolution will orchestrate calls to various MCP tools.

### Section 7: Multi-Tenancy, Security & Compliance

**1. Key Functionalities Identified:**
    - **Tenant Isolation:** RLS in PostgreSQL, Vector DB namespacing/filtering, tenant ID in agent logs & event bus payloads.
    - **RBAC:** Admin, Manager, Staff, Support Agent, AI Agent roles; enforcement via JWT & RLS.
    - **Authentication & Token Scoping:** Supabase Auth, JWT custom claims (`tenant_id`, `role`), agent-specific scoped JWTs.
    - **Secure Config Management:** External Secrets Manager, encrypted `tenant_config` table for per-tenant external keys, RLS for `agent_learning_config` & `agent_prompt_templates`. `pgcrypto` for DB field encryption.
    - **Audit Logging:** `agent_logs`, `system_logs`, `audit_logs` with detailed fields and retention policies.
    - **Data Residency & Compliance (GDPR, CCPA, SOC 2, HIPAA optional):** Regional deployment, LLM DPA registry, Compliance Escalation Mode.
    - **PII Handling & Encryption:** PII Classification Registry (`data_classification_registry`), encryption at rest & in transit, PII masking/redaction in logs & LLM interactions.
    - **Zero-Trust Architecture:** Principles like explicit verification, least privilege, scoped execution.
    - **Admin Controls:** Approval workflows for config changes, sensitive log access, user management, MFA.
    - **Security Testing:** Red teaming for LLMs, infrastructure penetration testing, session management security (token revocation list).

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
        - (Reinforced) `manage_pg_rls_policy` and ensuring queries respect RLS context.
        - `get_encrypted_db_field(tenant_id, table, field, record_id)` (Conceptual - if not transparent via pgcrypto & user context).
        - `set_encrypted_db_field(tenant_id, table, field, record_id, plain_value)` (Conceptual - if not transparent).
        - `log_audit_trail_event(tenant_id, user_id, session_id, action_enum, entity_type, entity_id, changed_fields_json, ip_address, user_agent, status_enum, failure_reason)`: For `audit_logs`.
        - `get_pii_classification(field_name_or_path)`: Queries `data_classification_registry`.
        - `manage_pii_classification_entry(action, entry_details)`: CRUD for `data_classification_registry`.
        - `add_jwt_to_revocation_list(jti, expiry_timestamp)`: If DB-based JWT revocation is used.
        - `is_jwt_revoked(jti)`: Checks revocation list.

    b. **Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
        - `manage_user_mfa_status(user_id, action_enable_disable)`: Interacts with Supabase Auth for MFA.
        - `revoke_supabase_user_session(user_id, session_id_or_all)`: If Supabase Auth provides such an API.
        - **Secrets Management (if using Supabase Vault, otherwise new category):**
            - `get_app_secret(secret_name)`
            - `set_app_secret(secret_name, secret_value)`

    c. **Settings Management Tools (`tools/settings_management/settings_management_tools.py`)**
        - (Reinforced) Managing `tenant_config` (encrypted per-tenant external API keys).
        - (Reinforced) Managing `data_classification_registry` (if stored as a configurable table).

    d. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
        - (Reinforced) `dispatch_agent_task_to_runner` must ensure it creates/passes appropriately scoped, short-lived JWTs for agent runners, incorporating `tenant_id` and a minimal agent-specific role. This might involve a helper function or service for minting these scoped tokens.

    e. **Secrets Management Tools (NEW - `tools/secrets_management/secrets_manager_tools.py` - if external, e.g., HashiCorp Vault)**
        - `get_external_secret(secret_path_or_name)`
        - `set_external_secret(secret_path_or_name, secret_value)`
        - `manage_secret_rotation_policy(secret_name, policy_details)`

**3. High-Level Implementation Notes (MCP Perspective):**
    - RLS policy enforcement is paramount and relies on correct session context (`app.current_tenant_id`, `app.current_role`) being set by API layers before MCP tools (especially DB tools) are called.
    - Encryption/decryption logic for sensitive DB fields needs careful implementation if not handled transparently by `pgcrypto` at the connection/user level.
    - The PII Classification Registry is a key component; MCP tools will be needed to manage and query it.
    - A robust solution for JWT revocation (e.g., Redis-based list, DB table) needs to be implemented and checked by auth middleware, potentially with MCP tool support for managing the list.
    - If an external secrets manager like HashiCorp Vault is used, a new MCP tool category will be required to interface with it.

### Section 8: DevOps, Scaling & Deployment

**1. Key Functionalities Identified:**
    - Secure and dynamic management of secrets for IaC and application services.
    - Scheduling of database tasks via `pg_cron` initiated by application logic.
    - Dynamic feature flagging for controlling feature availability and graceful degradation.
    - Operational capabilities for self-healing, such as restarting agent runners or querying their status.
    - Dynamic adjustment of service runtime configurations.
    - API-level policy enforcement using OPA, potentially requiring dynamic data fetching.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Secrets Management Tools (`tools/secrets_management/secrets_manager_tools.py`)** (Reinforced - from Sec 7, heavily used by Sec 8 processes)
        - `get_external_secret(secret_path_or_name)`: Used by IaC, CI/CD, and services to fetch secrets.
        - `set_external_secret(secret_path_or_name, secret_value)`: For managing secrets if updated programmatically.

    b. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)** (Enhancement)
        - `schedule_db_task(tenant_id, cron_expression, task_name, task_sql_or_function_name, task_parameters_json=None)`: Allows agents or system components to schedule recurring or future database tasks using `pg_cron`.
        - `get_tenant_subscription_details(tenant_id)` (Potential - if OPA needs this for API policy): Fetches tenant subscription tier or specific entitlements for OPA policy decisions.

    c. **Feature Flag Management Tools (NEW - `tools/feature_flags/feature_flag_tools.py`)**
        - `is_feature_flag_enabled(tenant_id_or_global, user_id_or_context, flag_name)`: Checks if a feature flag is active for a given context (tenant, user, or global).
        - `get_feature_flag_variant(tenant_id_or_global, user_id_or_context, flag_name)`: Gets the specific variant (e.g., 'A', 'B', 'control') of a feature flag.
        - `get_all_feature_flags_for_context(tenant_id_or_global, user_id_or_context)`: Retrieves all applicable feature flags and their states/variants for a given context.

    d. **Operational Tools (NEW - `tools/operational_tools/operational_tools.py`)**
        - `get_service_status(tenant_id_or_global, service_name_or_group, instance_id=None)`: Retrieves status of specified services or agent runners.
        - `restart_service_instance(tenant_id_or_global, service_name_or_group, instance_id=None)`: Initiates a restart of specified service instances or agent runners (e.g., for self-healing).
        - `trigger_canary_analysis(service_name, new_version_details, baseline_version_details)` (Potential - if CI/CD needs to trigger this programmatically via MCP).

    e. **Settings Management Tools (`tools/settings_management/settings_management_tools.py`)** (Enhancement)
        - `update_service_runtime_setting(tenant_id_or_global, service_name, setting_key, setting_value)`: Allows dynamic updates to specific runtime settings of a service, potentially used by self-healing or admin actions.

**3. High-Level Implementation Notes (MCP Perspective):**
    - Feature Flag tools will require integration with a feature flag management system (e.g., LaunchDarkly, Flagsmith SDK, or an internal DB-backed solution). MCP tools provide a standardized interface.
    - `schedule_db_task` will need to construct and execute SQL commands to interact with `pg_cron` functions securely.
    - Operational tools (`get_service_status`, `restart_service_instance`) will likely interact with the underlying orchestration platform (e.g., Kubernetes API) or a custom control plane. Permissions must be carefully managed.
    - `get_tenant_subscription_details` would query the relevant billing/tenant management tables.
    - `update_service_runtime_setting` needs a mechanism for services to pick up configuration changes (e.g., polling, push notifications, restart).

### Section 9: AI Memory & Embedding Vector Intelligence Layer

**1. Key Functionalities Identified:**
    - Embedding generation for various information sources using primary and secondary models.
    - Storing and indexing embeddings in PostgreSQL with pgvector, including HNSW index management.
    - Advanced metadata tagging (semantic, keyword, LLM-based) and management of a tag ontology.
    - Vector search and retrieval via a "Vector Bridge" component, supporting hybrid search, filtering, and re-ranking.
    - Context assembly for LLM consumption, including PII redaction and source attribution.
    - Embedding lifecycle management (scoring, decay, culling/GC).
    - Tenant isolation and security for embedding data.
    - Embedding model governance (registry, versioning, backfilling, cost monitoring).
    - Cross-agent embedding interoperability.
    - AI ReflectionAgent integration for analyzing and improving embedding performance.
    - Performance optimization and monitoring for the embedding layer.

**2. Required MCP Tool Categories & Specific Functions:**

    a. **Direct Database Interaction Tools (`tools/databases/database_tools.py`)** (Enhancements & New)
        - `insert_pg_vector_embedding(...)`: (Reinforced) Heavily used.
        - `search_pg_vector_embeddings(...)`: (Reinforced) Heavily used.
        - `update_pg_vector_embedding_access(...)`: (Reinforced) For `last_accessed_at`, `retrieval_count`.
        - `run_pg_vector_gc_job(tenant_id)`: (Reinforced) For culling.
        - `manage_pg_hnsw_index_parameters(tenant_id, index_name, ef_search, ef_construction, m)`: To tune HNSW index parameters.
        - `get_embedding_metadata(embedding_id)`: Fetches metadata for a specific embedding.
        - `update_embedding_metadata(embedding_id, metadata_updates_json)`: Updates specific fields in an embedding's metadata.
        - `get_embedding_model_details(model_name, model_version=None)`: Fetches details from `embedding_models` table.
        - `list_active_embedding_models(capabilities_filter_array=None)`: Lists active models, optionally filtered by capabilities.
        - `log_embedding_backfill_job(job_details_json)`: Logs status/progress of backfill jobs.
        - `get_next_embedding_backfill_batch(job_id, batch_size)`: Fetches next batch for a backfill job.
        - `update_embedding_backfill_job_status(job_id, status, processed_count, error_count)`: Updates backfill job status.
        - `get_tenant_tag_definitions(tenant_id)`: Fetches custom tags for a tenant.
        - `manage_tenant_tag_definition(tenant_id, action, tag_details_json)`: CRUD for tenant custom tags.
        - `get_core_tag_taxonomy()`: Fetches the centrally managed tag taxonomy.
        - `log_vector_retrieval_event(log_details_json)`: Logs details of a vector retrieval operation for analysis.
        - `get_vector_retrieval_statistics(tenant_id, time_window_hours, filters_json)`: Aggregates retrieval stats.
        - `get_embedding_outcome_correlations(tenant_id, time_window_hours, filters_json)`: Correlates embedding usage with agent outcomes.
        - `get_embedding_quality_metrics(tenant_id, time_window_hours, filters_json)`: Fetches quality metrics.
        - `get_model_drift_audit_logs(tenant_id, model_name, time_window_hours)`: Fetches logs from `model_drift_audit` table.
        - `log_model_drift_audit_entry(entry_details_json)`: Logs an entry to `model_drift_audit`.
        - `get_embedding_model_evaluation_results(model_id_or_name, dataset_id=None)`: Fetches evaluation results for models.
        - `log_embedding_model_evaluation_result(result_details_json)`: Logs a model evaluation result.
        - `get_agent_embedding_access_rules(agent_name_or_type)`: Fetches access rules for agents.
        - `manage_agent_embedding_access_rule(action, rule_details_json)`: CRUD for agent access rules.

    b. **AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)** (Enhancements)
        - `generate_embedding_with_model(text_or_texts_array, model_name, model_version=None, tenant_id=None, priority='normal')`: Generates embeddings using a specified model (handles batching).
        - `generate_semantic_tags_and_summary(text, model_name='claude-3-haiku', tenant_id=None)`: Uses an LLM for advanced tagging and summarization.
        - `invoke_context_harmonizer_agent(conflicting_context_items_array, tenant_id)` (Potential - Mastery Suggestion): For resolving conflicting context.

    c. **Message Queue Interaction Tools (`tools/message_queues/message_queue_tools.py`)** (Enhancements)
        - `publish_to_embedding_queue(event_payload_dict, priority='normal')`: Publishes to specific embedding priority queues (e.g., `stream:embedding:urgent`).
        - `consume_from_embedding_queue(priority='normal', consumer_group, consumer_name, count, block_ms)`: Consumes from embedding queues.
        - `publish_to_embedding_dlq(failed_event_payload_dict, error_details_json)`: Publishes to `stream:embedding:dlq`.

    d. **Vector Database Interaction Tools (`tools/vector_databases/vector_databases_tools.py`)** (Enhancements - if external DBs are used)
        - `trigger_external_vector_reindex(database_type, collection_name, filters_json=None)`: For external vector DBs.
        - `backup_external_vector_collection(database_type, collection_name, destination_uri)`: For external DBs.
        - `restore_external_vector_collection(database_type, collection_name, source_uri)`: For external DBs.

    e. **Settings Management Tools (`tools/settings_management/settings_management_tools.py`)** (Enhancements)
        - `get_tenant_embedding_configuration(tenant_id)`: Fetches tenant-specific embedding settings (default model, secondary model rules, budget).
        - `update_tenant_embedding_configuration(tenant_id, config_updates_json)`: Updates tenant embedding settings.
        - `get_system_default_embedding_model_id()`: Gets the ID of the system's default embedding model.

    f. **Operational Tools (`tools/operational_tools/operational_tools.py`)** (Enhancements)
        - `get_embedding_worker_status(priority_filter=None)`: Gets status of embedding service workers.
        - `scale_embedding_workers(priority, desired_count_delta)`: Adjusts the number of embedding workers for a given priority.

**3. High-Level Implementation Notes (MCP Perspective):**
    - The Vector Bridge component is central and will consume many DB and AI Agent tools.
    - Extensive use of JSONB for metadata requires careful schema design and query optimization.
    - RLS policies for `agent_memory_embeddings` and related tables (`embedding_models`, `embedding_backfill_jobs`, etc.) are critical.
    - The Embedding Service worker logic will be complex, involving calls to PII scanning, embedding models, and DB insertion with deduplication.
    - ReflectionAgent integration requires tools to fetch aggregated performance data and potentially apply recommended changes to configurations or metadata.
    - Cost monitoring and budget controls for embedding generation need robust implementation.

---
## Consolidated MCP Tool List (To be built incrementally)

**1. Supabase Stack Interaction Tools (`tools/supabase/supabase_tools.py`)**
    - `get_tenant_theme(tenant_id)`
    - `log_ui_event(tenant_id, event_type, payload)`
    - `get_tenant_validation_rules(tenant_id)`
    - `get_tenant_table_config(tenant_id)`
    - `get_tenant_accessibility_config(tenant_id)`
    - `log_system_event(tenant_id, event_type, payload)`
    - `log_system_metric(tenant_id, metric_name, value_payload)`
    - `get_tenant_service_config(tenant_id)`
    - `manage_supabase_user(action, user_details)`
    - `get_file_storage_url(action, tenant_id, file_path, content_type=None)`
    - `delete_file_from_supabase_storage(tenant_id, storage_path)`
    - `invoke_edge_function(function_name, payload)`
    - `manage_user_mfa_status(user_id, action_enable_disable)`
    - `revoke_supabase_user_session(user_id, session_id_or_all)`
    - `get_app_secret(secret_name)` (If using Supabase Vault)
    - `set_app_secret(secret_name, secret_value)` (If using Supabase Vault)
    - `get_tenant_icon_set_config(tenant_id)` (Potential)
    - `get_tenant_grid_config(tenant_id)` (Potential)

**2. AI Agent Interaction Tools (`tools/ai_agents/ai_agent_tools.py`)**
    - `get_ai_input_suggestions(tenant_id, current_input_context)`
    - `get_ai_suggested_actions(tenant_id, current_context)`
    - `generate_ai_alt_text(image_url, image_type, tenant_id)`
    - `predict_event_priority(tenant_id, event_details)`
    - `predict_cache_ttl(tenant_id, cache_key_details)`
    - `predict_hnsw_params(tenant_id, table_name)`
    - `predict_service_config(tenant_id, service_name, current_config)`
    - `dispatch_agent_task_to_runner(runner_details, execution_contract)`
    - `invoke_reflection_agent(trigger_payload)`
    - `trigger_llm_finetuning_pipeline(model_provider_details, dataset_reference, new_model_identifier)` (Potential)
    - `generate_embedding_with_model(text_or_texts_array, model_name, model_version=None, tenant_id=None, priority='normal')`
    - `generate_semantic_tags_and_summary(text, model_name='claude-3-haiku', tenant_id=None)`
    - `invoke_context_harmonizer_agent(conflicting_context_items_array, tenant_id)` (Potential)

**3. Offline-First Sync Tools (`tools/offline_sync/offline_sync_tools.py`)** (Potential)
    - `process_offline_mutation_batch(mutations)`

**4. Message Queue Interaction Tools (`tools/message_queues/message_queue_tools.py`)**
    - `initialize_tenant_rabbitmq_queue(tenant_id)` (If RabbitMQ still used for specific parts)
    - `publish_to_rabbitmq_queue(tenant_id, event_payload, urgency_level)` (If RabbitMQ still used)
    - `get_rabbitmq_queue_depth(tenant_id, queue_name)` (If RabbitMQ still used)
    - `publish_to_redis_stream(stream_name, event_payload_dict)`
    - `consume_from_redis_stream(stream_name, consumer_group, consumer_name, count, block_ms)`
    - `acknowledge_redis_stream_message(stream_name, consumer_group, message_id)`
    - `publish_to_embedding_queue(event_payload_dict, priority='normal')`
    - `consume_from_embedding_queue(priority='normal', consumer_group, consumer_name, count, block_ms)`
    - `publish_to_embedding_dlq(failed_event_payload_dict, error_details_json)`

**5. Caching Interaction Tools (`tools/caching/caching_tools.py`)**
    - `get_cached_item(tenant_id, cache_key)`
    - `set_cached_item(tenant_id, cache_key, item_data, custom_ttl=None)`
    - `invalidate_cache_key(tenant_id, cache_key_pattern)`

**6. Direct Database Interaction Tools (`tools/databases/database_tools.py`)**
    - `execute_pg_query(tenant_id, query_text, params, use_replica=True)`
    - `execute_pg_transaction(tenant_id, list_of_queries_and_params)`
    - `manage_pg_enum_type(action, type_name, values)`
    - `manage_pg_table(action, table_definition)`
    - `manage_pg_rls_policy(action, table_name, policy_name, policy_definition)`
    - `create_pg_tenant_index(tenant_id, table_name, column_names, index_type)`
    - `tune_pg_hnsw_index(tenant_id, index_name, ef_construction, m)`
    - `create_pg_tenant_partition(tenant_id, table_name, partition_logic_details)`
    - `insert_pg_vector_embedding(tenant_id, entity_type, entity_id, embedding, metadata, source_text_hash, source_text, priority)`
    - `search_pg_vector_embeddings(tenant_id, query_vector, filters, top_k)`
    - `update_pg_vector_embedding_access(tenant_id, embedding_id, access_timestamp)`
    - `run_pg_vector_gc_job(tenant_id)`
    - `get_agent_registry_capabilities(agent_names_list)`
    - `get_event_routing_rules(event_type, source_criteria)`
    - `get_agent_runner_details(agent_type_filter)`
    - `register_agent_runner_instance(runner_details)`
    - `get_acp_hybrid_policy_config(tenant_id)`
    - `log_acp_ledger_entry(event_id, tenant_id, agent_id, task_id, resolution, explanation_json)`
    - `get_vector_policy_config(tenant_id)`
    - `update_vector_policy_config(tenant_id, ef_search, m)`
    - `get_priority_model_weight(tenant_id, agent_id, task_type)`
    - `update_priority_model_weight(tenant_id, agent_id, task_type, weight)`
    - `get_all_priority_models_for_aggregation()`
    - `store_global_priority_model_weights(model_id, agent_id, task_type, weight)`
    - `update_agent_log_feedback_extrinsic(agent_log_id, user_id, feedback_rating, feedback_comment)`
    - `update_agent_log_metrics_intrinsic(agent_log_id, metrics_payload)`
    - `query_agent_logs_for_reflection_analysis(query_parameters)`
    - `flag_agent_log_as_finetune_candidate(agent_log_id, is_candidate, reason)`
    - `log_reflection_agent_output(reflection_run_id, recommendations_payload, bias_check_results)`
    - `get_agent_learning_config_data(agent_name)`
    - `update_agent_learning_config_data(agent_name, config_updates)`
    - `get_agent_prompt_template_details(prompt_id_or_name, version_tag=None)`
    - `create_new_agent_prompt_template(template_data)`
    - `update_existing_agent_prompt_template(prompt_id, updates_payload)`
    - `get_active_agent_prompt(agent_name)`
    - `update_agent_memory_embedding_expiry(embedding_id, expires_at_timestamp)`
    - `log_audit_trail_event(tenant_id, user_id, session_id, action_enum, entity_type, entity_id, changed_fields_json, ip_address, user_agent, status_enum, failure_reason)`
    - `get_pii_classification_for_field(field_identifier)`
    - `manage_pii_classification_entry(action, entry_details)`
    - `add_jwt_to_revocation_list(jti, expiry_timestamp)` (If DB-based)
    - `is_jwt_revoked(jti)` (If DB-based)
    - `get_decrypted_tenant_config_value(tenant_id, key_name)` (Conceptual)
    - `set_encrypted_tenant_config_value(tenant_id, key_name, plain_value)` (Conceptual)
    - (Reinforced) `get_agent_definition`, `update_agent_definition`
    - Specific CRUD helpers for core tables (e.g., `create_lead`, `get_bookings_for_staff`, `log_interaction`, `log_agent_execution`, `log_billing_token_usage`, `get_file_metadata`, `create_file_metadata`, `delete_file_metadata`).
    - `schedule_db_task(tenant_id, cron_expression, task_name, task_sql_or_function_name, task_parameters_json=None)`
    - `get_tenant_subscription_details(tenant_id)` (Potential)
    - `manage_pg_hnsw_index_parameters(tenant_id, index_name, ef_search, ef_construction, m)`
    - `get_embedding_metadata(embedding_id)`
    - `update_embedding_metadata(embedding_id, metadata_updates_json)`
    - `get_embedding_model_details(model_name, model_version=None)`
    - `list_active_embedding_models(capabilities_filter_array=None)`
    - `log_embedding_backfill_job(job_details_json)`
    - `get_next_embedding_backfill_batch(job_id, batch_size)`
    - `update_embedding_backfill_job_status(job_id, status, processed_count, error_count)`
    - `get_tenant_tag_definitions(tenant_id)`
    - `manage_tenant_tag_definition(tenant_id, action, tag_details_json)`
    - `get_core_tag_taxonomy()`
    - `log_vector_retrieval_event(log_details_json)`
    - `get_vector_retrieval_statistics(tenant_id, time_window_hours, filters_json)`
    - `get_embedding_outcome_correlations(tenant_id, time_window_hours, filters_json)`
    - `get_embedding_quality_metrics(tenant_id, time_window_hours, filters_json)`
    - `get_model_drift_audit_logs(tenant_id, model_name, time_window_hours)`
    - `log_model_drift_audit_entry(entry_details_json)`
    - `get_embedding_model_evaluation_results(model_id_or_name, dataset_id=None)`
    - `log_embedding_model_evaluation_result(result_details_json)`
    - `get_agent_embedding_access_rules(agent_name_or_type)`
    - `manage_agent_embedding_access_rule(action, rule_details_json)`

**7. Workflow Management Tools (`tools/workflow_management/workflow_management_tools.py`)**
    - `create_workflow_definition(tenant_id, name, description, trigger_type, trigger_config, structure_json)`
    - `update_workflow_definition(tenant_id, workflow_def_id, updates_json)`
    - `get_workflow_definition(tenant_id, workflow_def_id)`
    - `activate_workflow_definition(tenant_id, workflow_def_id, is_active_flag)`
    - `trigger_workflow_run(tenant_id, workflow_def_id, trigger_event_data, input_context)`
    - `get_workflow_run_details(tenant_id, workflow_run_id)`
    - `update_workflow_run(tenant_id, workflow_run_id, status, current_step_id, steps_state_updates, error_log_updates)`
    - `trigger_admin_approval_workflow(recommendation_id, recommendation_details)`
    - `update_system_config_after_approval(approved_change_details)`

**8. Settings Management Tools (`tools/settings_management/settings_management_tools.py`)**
    - `get_agent_config_value(tenant_id, agent_name, config_key, version_tag=None)`
    - `set_agent_config_value(tenant_id, agent_name, config_key, config_value, version_tag=None, description=None)`
    - `manage_json_schema(action, schema_name, version, schema_definition_json)`
    - `get_tenant_settings(tenant_id)`
    - `update_tenant_settings(tenant_id, settings_payload)`
    - (Reinforced) Functions for ACP, vector tuning, federated learning configs.
    - (Reinforced) CRUD for `agent_learning_config`, `agent_prompt_templates`.
    - (Reinforced) Managing `tenant_config` (encrypted per-tenant external API keys).
    - (Reinforced) Managing `data_classification_registry` (if stored as a configurable table).
    - `update_service_runtime_setting(tenant_id_or_global, service_name, setting_key, setting_value)`
    - `get_tenant_embedding_configuration(tenant_id)`
    - `update_tenant_embedding_configuration(tenant_id, config_updates_json)`
    - `get_system_default_embedding_model_id()`

**9. Agent Log Review Tools (`tools/agent_log_review/agent_log_review_tools.py`)**
    - `query_agent_logs(tenant_id, filters)`
    - `get_agent_log_details(tenant_id, agent_log_id)`
    - `submit_agent_log_feedback(tenant_id, agent_log_id, user_id, rating, comment)`

**10. Vector Database Interaction Tools (`tools/vector_databases/vector_databases_tools.py`)**
    - `insert_vectors(...)` (Note: pgvector specific version is in Database tools, this is for external DBs if any)
    - `search_vectors(...)` (Note: pgvector specific version is in Database tools, this is for external DBs if any, used by Vector Bridge)
    - `manage_collection(...)` (For external DBs)
    - `trigger_vector_reindex(database_type, collection_name_or_index_name)`
    - `trigger_external_vector_reindex(database_type, collection_name, filters_json=None)`
    - `backup_external_vector_collection(database_type, collection_name, destination_uri)`
    - `restore_external_vector_collection(database_type, collection_name, source_uri)`

**11. Cloud Service Interaction Tools (`tools/cloud_services/aws_tools.py` or similar)**
    - `aggregate_with_nitro_enclave(data_to_aggregate, aggregation_config)` (If AWS Nitro Enclaves are used)

**12. Secrets Management Tools (`tools/secrets_management/secrets_manager_tools.py` - if external)**
    - `get_external_secret(secret_path_or_name)`
    - `set_external_secret(secret_path_or_name, secret_value)`
    - `manage_secret_rotation_policy(secret_name, policy_details)`

**13. Feature Flag Management Tools (`tools/feature_flags/feature_flag_tools.py`)**
    - `is_feature_flag_enabled(tenant_id_or_global, user_id_or_context, flag_name)`
    - `get_feature_flag_variant(tenant_id_or_global, user_id_or_context, flag_name)`
    - `get_all_feature_flags_for_context(tenant_id_or_global, user_id_or_context)`

**14. Operational Tools (`tools/operational_tools/operational_tools.py`)**
    - `get_service_status(tenant_id_or_global, service_name_or_group, instance_id=None)`
    - `restart_service_instance(tenant_id_or_global, service_name_or_group, instance_id=None)`
    - `trigger_canary_analysis(service_name, new_version_details, baseline_version_details)` (Potential)
    - `get_embedding_worker_status(priority_filter=None)`
    - `scale_embedding_workers(priority, desired_count_delta)`

*(Further tool categories and functions will be added as analysis progresses.)*

---
*This document is actively being updated.*